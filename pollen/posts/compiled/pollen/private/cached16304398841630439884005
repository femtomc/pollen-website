((3) 0 () 3 ("payload" "head" "highlight") () (h - () (metas h - () (template . "post-template.html") (here-path . "/Users/mccoybecker/dev/newsite/pollen/posts/disc_lambda_pt1.html.pm")) (doc c decoded-root c (c h1 c (u . "The untyped lambda calculus")) c (c p c (u . "The untyped ") c (c mathjax c (u . "\\(\\lambda\\)")) c (u . "-calculus is a dense representation of universal computation. In untyped form, the lambda calculus consists of symbolic terms built from the following objects:")) c (c h3 c (c (c class c (u . "subhead foldable"))) c (c a c (c (c href c (u . "javascript:toggle_div('g25214')"))) c (u . "Variable"))) c (c div c (c (c style c (u . "display:none;")) c (c id c (u . "g25214")) c (c class c (? . 0))) c (c p c (c mathjax c (u . "\\begin{equation}x, y, z...\\end{equation}")) c (q br) c (u . "An identifier representing a mathematical or logical value."))) c (c h3 c (c (c class c (u . "subhead foldable"))) c (c a c (c (c href c (u . "javascript:toggle_div('g25215')"))) c (u . "Lambda abstraction"))) c (c div c (c (c style c (u . "display:none;")) c (c id c (u . "g25215")) c (c class c (? . 0))) c (c p c (c mathjax c (u . "\\begin{equation}(\\lambda \\ x. M)\\end{equation}")) c (q br) c (c mathjax c (u . "\\(M\\)")) c (u . " is called a lambda term. The notation ") c (c mathjax c (u . "\\(\\lambda \\ x.(...)\\)")) c (u . " means that ") c (c mathjax c (u . "\\(x\\)")) c (u . " is bound in the ") c (c mathjax c (u . "\\(M\\)")) c (u . " term.")) c (c p c (u . "Together, with application, this allows the definition and application of procedures."))) c (c h3 c (c (c class c (u . "subhead foldable"))) c (c a c (c (c href c (u . "javascript:toggle_div('g25216')"))) c (u . "Application"))) c (c div c (c (c style c (u . "display:none;")) c (c id c (u . "g25216")) c (c class c (? . 0))) c (c p c (c mathjax c (u . "\\begin{equation}(M N)\\end{equation}")) c (q br) c (u . "Apply a function to an argument. ") c (c mathjax c (u . "\\(M\\)")) c (u . " and ") c (c mathjax c (u . "\\(N\\)")) c (u . " are both lambda terms."))) c (c p c (u . "With a suitably defined evaluation semantics (e.g. how terms transformation / reduce to other terms) - this language (plus semantics) is Turing complete, which means it can be used to simulate any Turing machine, including ") c (c a c (q (href "https://en.wikipedia.org/wiki/Universal_Turing_machine")) c (u . "a universal one")) c (u . ".")) c (c h2 c (c (c class c (? . 1))) c (u . "Application")) c (c p c (u . "We have to give application a transformation semantics - which means we need to define what it means for the term ") c (c mathjax c (u . "\\(M\\)")) c (u . " to apply to ") c (c mathjax c (u . "\\(N\\)")) c (u . " in the application term ") c (c mathjax c (u . "\\((M N)\\)")) c (u . ".")) c (c p c (u . "To get a feel for this question, let’s study some lambda abstraction terms.")) c (c p c (c mathjax c (u . "\\begin{align}&\\lambda \\ x. x \\\\\n&\\lambda \\ x. \\lambda \\ y. (x \\ y)\\end{align}"))) c (c p c (u . "Now, we can immediately identify a rule: we can rename bound variables as long as we do so consistently throughout a lambda term.")) c (c h3 c (c (c class c (u . "subhead foldable"))) c (c a c (c (c href c (u . "javascript:toggle_div('g25217')"))) c (u . "Alpha conversion"))) c (c div c (c (c style c (u . "display:none;")) c (c id c (u . "g25217")) c (c class c (? . 0))) c (c p c (c mathjax c (u . "\\begin{equation}\\lambda \\ x . x \\rightarrow \\lambda \\ y . y\\end{equation}"))) c (c p c (u . "The name representation of bound variables can be changed as long as the change is applied consistently throughout a ") c (c mathjax c (u . "\\(\\lambda\\)")) c (u . "-term."))) c (c p c (u . "Let’s also consider a rule which allows us to define a transformation semantics for application: when applying a ") c (c mathjax c (u . "\\(\\lambda\\)")) c (u . "-term to another term ") c (c mathjax c (u . "\\(N\\)")) c (u . " - all occurrences of the outermost bound variable in ") c (c mathjax c (u . "\\(M\\)")) c (u . " are replaced by ") c (c mathjax c (u . "\\(N\\)")) c (u . ".")) c (c h3 c (c (c class c (u . "subhead foldable"))) c (c a c (c (c href c (u . "javascript:toggle_div('g25218')"))) c (u . "Beta reduction"))) c (c div c (c (c style c (u . "display:none;")) c (c id c (u . "g25218")) c (c class c (? . 0))) c (c p c (c mathjax c (u . "\\begin{equation}(M(x) \\ N) \\rightarrow M[x \\rightarrow N]\\end{equation}"))) c (c p c (u . "Here, the notation ") c (c mathjax c (u . "\\(M(x)\\)")) c (u . " denotes that ") c (c mathjax c (u . "\\(x\\)")) c (u . " is bound in the term ") c (c mathjax c (u . "\\(M\\)")) c (u . ". The ") c (c mathjax c (u . "\\(\\beta-\\text{reduction}\\)")) c (u . " rule says “replace all occurrences of ") c (c mathjax c (u . "\\(x\\)")) c (u . " in ") c (c mathjax c (u . "\\(M\\)")) c (u . " with ") c (c mathjax c (u . "\\(N\\)")) c (u . "”."))) c (c p c (u . "Why do we need ") c (c mathjax c (u . "\\(\\alpha\\)")) c (u . "-conversion at all? To avoid ambiguity, if I want to substitute a term ") c (c mathjax c (u . "\\(N\\)")) c (u . " into ") c (c mathjax c (u . "\\(M\\)")) c (u . " via ") c (c mathjax c (u . "\\(\\beta\\)")) c (u . "-reduction - to avoid namespace collisions, I may have to rename bound variables / free variables in ") c (c mathjax c (u . "\\(N\\)")) c (u . ".")) c (c h3 c (q (class "subhead")) c (u . "Evaluation order")) c (c p c (u . "There’s actually one more form of ambiguity which we need to handle with a rule - this form of ambiguity arises when considering the evaluation order of subterms in an application term.")) c (c p c (c img c (c (q class "latex") c (c src c (u . "compiled/images/latex_1143290705308394075.png"))))) c (c h2 c (c (c class c (? . 1))) c (u . "Interpreter")) c (c p c (c span c (q (class "defined-term")) c (c a c (q (href "https://github.com/femtomc/untyped-lambda") (class "ext")) c (u . "Source code for the interpreter is available here.")))) c (c p c (u . "In a language like Haskell (with algebraic data types) - we can swiftly construct an interpreter for the untyped lambda calculus, as long as we agree upon an evaluation order. Let’s begin with a data type for terms:")) c (c div c (c (c class c (? . 2))) c (c table c (c (c class c (u . "sourcetable"))) c (c tbody c (c tr c (c td c (c (c class c (u . "linenos"))) c (c div c (c (c class c (u . "linenodiv"))) c (c pre c (c span c (c (c class c (u . "normal"))) c (u . "1")) c (u . "\n") c (c span c (c (c class c (u . "normal"))) c (u . "2")) c (u . "\n") c (c span c (c (c class c (u . "normal"))) c (u . "3"))))) c (c td c (c (c class c (u . "code"))) c (c div c (c (c class c (u . "source"))) c (c pre c (q span) c (c span c (c (c class c (u . "kr"))) c (u . "data")) c (u . " ") c (c span c (c (c class c (u . "kt"))) c (u . "Term")) c (u . " ") c (c span c (c (c class c (u . "ow"))) c (u . "=")) c (u . " ") c (c span c (c (c class c (u . "kt"))) c (u . "Var")) c (u . " ") c (c span c (c (c class c (u . "kt"))) c (u . "String")) c (u . "\n          ") c (c span c (c (c class c (u . "o"))) c (u . "|")) c (u . " ") c (c span c (c (c class c (u . "kt"))) c (u . "Lam")) c (u . " ") c (c span c (c (c class c (u . "kt"))) c (u . "Var")) c (u . " ") c (c span c (c (c class c (u . "kt"))) c (u . "Term")) c (u . "\n          ") c (c span c (c (c class c (u . "o"))) c (u . "|")) c (u . " ") c (c span c (c (c class c (u . "kt"))) c (u . "App")) c (u . " ") c (c span c (c (c class c (u . "kt"))) c (u . "Term")) c (u . " ") c (c span c (c (c class c (u . "kt"))) c (u . "Term")) c (u . "\n")))))))) c (c p c (u . "Now, as mentioned above - we can construct lambda abstractions with whatever bound / free variable names we want - but when we choose to perform ") c (c mathjax c (u . "\\(\\beta\\)")) c (u . "-reduction, we will need to identify if there are collisions and apply ") c (c mathjax c (u . "\\(\\alpha\\)")) c (u . "-conversion.")) c (c p c (c mathjax c (u . "\\(\\alpha\\)")) c (u . "-conversion need only apply when looking at ") c (q span ((class "my-code") (decode "exclude")) "App Term Term") c (u . ".")) c (c div c (c (c class c (? . 2))) c (c table c (c (c class c (u . "sourcetable"))) c (c tbody c (c tr c (c td c (c (c class c (u . "linenos"))) c (c div c (c (c class c (u . "linenodiv"))) c (c pre c (c span c (c (c class c (u . "normal"))) c (u . "1")) c (u . "\n") c (c span c (c (c class c (u . "normal"))) c (u . "2")) c (u . "\n") c (c span c (c (c class c (u . "normal"))) c (u . "3")) c (u . "\n") c (c span c (c (c class c (u . "normal"))) c (u . "4")) c (u . "\n") c (c span c (c (c class c (u . "normal"))) c (u . "5"))))) c (c td c (c (c class c (u . "code"))) c (c div c (c (c class c (u . "source"))) c (c pre c (q span) c (c span c (c (c class c (u . "nf"))) c (u . "alpha_conv")) c (u . " ") c (c span c (c (c class c (u . "ow"))) c (u . "::")) c (u . " ") c (c span c (c (c class c (u . "kt"))) c (u . "Term")) c (u . " ") c (c span c (c (c class c (u . "ow"))) c (u . "-") q ">") c (u . " ") c (c span c (c (c class c (u . "kt"))) c (u . "Term")) c (u . "\n") c (c span c (c (c class c (u . "nf"))) c (u . "alpha_conv")) c (u . " ") c (c span c (c (c class c (u . "kt"))) c (u . "Var")) c (u . " ") c (c span c (c (c class c (u . "n"))) c (u . "s")) c (u . " ") c (c span c (c (c class c (u . "ow"))) c (u . "=")) c (u . " ") c (c span c (c (c class c (u . "kt"))) c (u . "Var")) c (u . " ") c (c span c (c (c class c (u . "n"))) c (u . "s")) c (u . "\n") c (c span c (c (c class c (u . "nf"))) c (u . "alpha_conv")) c (u . " ") c (c span c (c (c class c (u . "kt"))) c (u . "Lam")) c (u . " ") c (c span c (c (c class c (u . "n"))) c (u . "v")) c (u . " ") c (c span c (c (c class c (u . "n"))) c (u . "t")) c (u . " ") c (c span c (c (c class c (u . "ow"))) c (u . "=")) c (u . " ") c (c span c (c (c class c (u . "kt"))) c (u . "Lam")) c (u . " ") c (c span c (c (c class c (u . "n"))) c (u . "v")) c (u . " ") c (c span c (c (c class c (u . "n"))) c (u . "t")) c (u . "\n") c (c span c (c (c class c (u . "nf"))) c (u . "alpha_conv")) c (u . " ") c (c span c (c (c class c (u . "kt"))) c (u . "App")) c (u . " ") c (c span c (c (c class c (u . "n"))) c (u . "t1")) c (u . " ") c (c span c (c (c class c (u . "n"))) c (u . "t2")) c (u . " ") c (c span c (c (c class c (u . "ow"))) c (u . "=")) c (u . " ") c (c span c (c (c class c (u . "kr"))) c (u . "let")) c (u . " ") c (c span c (c (c class c (u . "n"))) c (u . "names")) c (u . " ") c (c span c (c (c class c (u . "ow"))) c (u . "=")) c (u . " ") c (c span c (c (c class c (u . "n"))) c (u . "get_names")) c (u . " ") c (c span c (c (c class c (u . "n"))) c (u . "t1")) c (u . " ") c (c span c (c (c class c (u . "kr"))) c (u . "in")) c (u . "\n    ") c (c span c (c (c class c (u . "kt"))) c (u . "App")) c (u . " ") c (c span c (c (c class c (u . "n"))) c (u . "t1")) c (u . " ") c (c span c (c (c class c (u . "o"))) c (u . "$")) c (u . " ") c (c span c (c (c class c (u . "n"))) c (u . "rename")) c (u . " ") c (c span c (c (c class c (u . "n"))) c (u . "t2")) c (u . " ") c (c span c (c (c class c (u . "n"))) c (u . "names")) c (u . "\n")))))))) c (c p c (u . "Here, we just pass through variable and lambda terms - but in application, we grab all the bound and free variables of the first term and ensure that the second term has no collisions.")))))